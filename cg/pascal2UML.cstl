program::
_1 interface _2 . _3 |-->
_1 _2 . _3 |-->_2`classDefinitions\n\n_1_2}\n\n


programHeading::
program _1 ; |-->class _1_Class {\n  static operation new_1_Class() : _1_Class\n  pre: true\n  post: _1_Class->exists( _x | _x.initialise() & result = _x );\n\n<action> _1 Program

program _1 ( _2 ) ; |-->class _1_Class {\n_2`progParsToAttributes\n  static operation new_1_Class() : _1_Class\n  pre: true\n  post: _1_Class->exists( _x | _x.initialise() & result = _x );\n\n<action> _1 Program


progParsToAttributes::
input |-->  attribute input : OclFile := OclFile["System.in"];\n  attribute input_buffer : String := null;\n
output |-->  attribute output : OclFile := OclFile["System.out"];\n  attribute output_buffer : String := null;\n  
_1 |--><action> _1`typName File

, input |-->  attribute input : OclFile := OclFile["System.in"];\n  attribute input_buffer : String := null;\n
, output |-->  attribute output : OclFile := OclFile["System.out"];\n  attribute output_buffer : String := null;\n
, _1 |--><action> _1`typName File


input , _* |-->  attribute input : OclFile := OclFile["System.in"];\n  attribute input_buffer : String := null;\n_*`recurse
output , _* |-->  attribute output : OclFile := OclFile["System.out"];\n  attribute output_buffer : String := null;\n_*`recurse
_1 , _* |-->_*`recurse<action> _1`typName File
, _* |-->_*`recurse



identifier::
MAXINT |-->(2->pow(31) - 1)->oclAsType(int)
MaxInt |-->(2->pow(31) - 1)->oclAsType(int)
maxint |-->(2->pow(31) - 1)->oclAsType(int)

PI |-->MathLib.piValue()
Pi |-->MathLib.piValue()
pi |-->MathLib.piValue()

_1 |-->_1



block::
_1 |-->  operation initialise()\n  pre: true post: true\n  activity:_1`gotoFunctions;\n
_1 _* |-->_1\n_*`recurse


functionBlock::
_1 |-->_1`localConstDec<when> _1 constantDefinitionPart
_1 |-->_1<when> _1 variableDeclarationPart
_1 |-->_1<when> _1 compoundStatement
_1 |-->_1`nestedFunctionVariables<when> _1 procedureAndFunctionDeclarationPart

_1 _* |-->_1`localConstDec\n_*`recurse<when> _1 constantDefinitionPart
_1 _* |-->_1`localVariableDecs\n_*`recurse<when> _1 variableDeclarationPart
_1 _* |-->_1`nestedFunctionVariables\n_*`recurse<when> _1 procedureAndFunctionDeclarationPart
_1 _* |-->_*`recurse
_1 |-->_1`functionBlock<when> _1 block
_1 |-->


nestedFunctions::
_1 |--><when> _1 constantDefinitionPart
_1 |--><when> _1 variableDeclarationPart
_1 |--><when> _1 compoundStatement
_1 |-->_1`nestedFunctionDeclarations<when> _1 procedureAndFunctionDeclarationPart

_1 _* |-->_*`recurse<when> _1 constantDefinitionPart
_1 _* |-->_*`recurse<when> _1 variableDeclarationPart
_1 _* |-->_1`nestedFunctionDeclarations\n_*`recurse<when> _1 procedureAndFunctionDeclarationPart
_1 _* |-->_*`recurse

_1 |--><when> _1 block
_1 |-->



classDefinitions::
_1 |-->
_1 _* |-->_1`recordClassDefinitions<when> _1 typeDefinitionPart
_1 _* |-->_*`recurse


labelDeclarationPart::
LABEL _* |-->
Label _* |-->
label _* |-->

label:: 
_1 |-->_1


constantDefinitionPart::
CONST _* |-->_*\n
Const _* |-->_*\n
const _* |-->_*\n

constantDefinition::
_1 = _2 |-->\n  attribute _1 : _2`ocltype := _2<action> _1 _2`ocltype


localConstDec::
_1 = _2 |-->\n  var _1 : _2`ocltype := _2<action> _1 _2`ocltype



constant::
- _1 |-->-_1
+ _1 |-->_1
_1 |-->_1

unsignedNumber::
_1 |-->_1

unsignedInteger::
_1 |-->_1

unsignedReal::
_1 |-->("_1"->toReal())<when> _1 matches .*E.*
_1 |-->("_1"->toReal())<when> _1 matches .*e.*
_1 |-->_1

sign::
+ |-->
- |-->-

bool_::
true |-->true
false |-->false
True |-->true
False |-->false
TRUE |-->true
FALSE |-->false


string::
_1 |-->_1



ocltype::
input |-->File
output |-->File

true |-->boolean
True |-->boolean
TRUE |-->boolean
false |-->boolean
False |-->boolean
FALSE |-->boolean

nil |-->OclAny
maxint |-->int
Nil |-->OclAny
Maxint |-->int
NIL |-->OclAny
MAXINT |-->int

_1 TO _2 |-->_1`ocltype
_1 To _2 |-->_1`ocltype
_1 to _2 |-->_1`ocltype

_1 DOWNTO _2 |-->_1`ocltype
_1 DownTo _2 |-->_1`ocltype
_1 Downto _2 |-->_1`ocltype
_1 downto _2 |-->_1`ocltype

_1 [ _2 ] |-->OclAny

_1 |-->int<when> _1 unsignedInteger
_1 |-->double<when> _1 unsignedReal
@ _1 |-->Ref
+ _1 |-->_1`ocltype
- _1 |-->_1`ocltype
. _1 |-->_1`ocltype

_1 |-->String<when> _1 string
_1 |-->String<when> _1 constantChr
_1 |-->boolean<when> _1 bool_
_1 |-->Set<when> _1 set_

_1 |-->_1`ocltype<when> _1 finalValue
_1 |-->_1`ocltype<when> _1 initialValue
_1 |-->_1`ocltype<when> _1 unsignedNumber
_1 |-->_1`ocltype<when> _1 constant
_1 |-->_1`ocltype<when> _1 unsignedConstant
_1 |-->_1`ocltype<when> _1 factor
_1 |-->_1`ocltype<when> _1 term
_1 |-->_1`ocltype<when> _1 signedFactor
_1 |-->_1`ocltype<when> _1 parameterList
_1 |-->_1`ocltype<when> _1 actualParameter
_1 |-->_1`ocltype<when> _1 expression
_1 |-->_1`ocltype<when> _1 simpleExpression
_1 |-->_1`ocltype<when> _1 functionDesignator
_1 |-->_1`ocltype<when> _1 variable

_1 |-->String<when> _1 String
_1 |-->int<when> _1 int
_1 |-->double<when> _1 real
_1 |-->Set<when> _1 Set
_1 |-->Entity<when> _1 Entity
_1 |-->File<when> _1 File

_1 |-->_1`typName<when> _1 identifier

( _1 ) |-->_1`ocltype

not _1 |-->boolean
_1 = _2 |-->boolean
_1 <> _2 |-->boolean
_1 < _2 |-->boolean
_1 <= _2 |-->boolean
_1 > _2 |-->boolean
_1 >= _2 |-->boolean
_1 in _2 |-->boolean
_1 or _2 |-->boolean
_1 and _2 |-->boolean

_1 + _2 |-->int<when> _1`ocltype int, _2`ocltype int
_1 + _2 |-->_1`ocltype
_1 - _2 |-->int<when> _1`ocltype int, _2`ocltype int
_1 - _2 |-->_1`ocltype
_1 * _2 |-->int<when> _1`ocltype int, _2`ocltype int
_1 * _2 |-->_1`ocltype
_1 div _2 |-->int
_1 mod _2 |-->int
_1 / _2 |-->double

sin ( _1 ) |-->double
cos ( _1 ) |-->double

odd ( _1 ) |-->boolean

arctan ( _1 ) |-->double

abs ( _1 ) |-->double
exp ( _1 ) |-->double
ln ( _1 ) |-->double
round ( _1 ) |-->int
trunc ( _1 ) |-->int

sqr ( _1 ) |-->double
sqrt ( _1 ) |-->double

chr ( _1 ) |-->String
eof ( _1 ) |-->boolean

ord ( _1 ) |-->int
succ ( _1 ) |-->_1`ocltype
pred ( _1 ) |-->_1`ocltype

random ( _1 ) |-->int

_1 ( _2 ) |-->OclAny




typeDefinitionPart::
type _* |-->_*`typeDefns\n

recordClassDefinitions::
type _* |-->_*`recordClassDefinitions
_1 = _2 |-->_2`nestedClasses\nclass _1 {\n_2`attributesFromFields\n\n  static operation new_1() : _1\n  pre: true\n  post: _1->exists( _x | result = _x );\n}\n\n<when> _2`isRecordType true <action> _1 Entity

_1 = _2 |-->\n  enumeration _1 { _2 }\n\n<when> _2`isScalarType true<action> _1`initValue _2`lowerBound
_1 = _2 |-->\n  datatype _1 = _2;\n<when> _2 functionType <action> _1 Function, _1`initValue _2`functInit
_1 = _2 |-->\n  datatype _1 = _2;\n<when> _2 procedureType <action> _1 Function
_1 = _2 |-->\n  datatype _1 = _2;\n<when> _2`isSetType true <action> _1 Set
_1 = _2 |-->\n  datatype _1 = _2;\n<when> _2`isArrayType true <action> _1 Map
_1 = _2 |-->\n  datatype _1 = _2;\n<when> _2`isFileType true <action> _1 File
_1 = _2 |-->\n  datatype _1 = _2`felemType;\n<when> _2`isSubrangeType<action> _1`initValue _2`lowerBound
_1 = _2 |-->\n  datatype _1 = _2;\n<action> _1`actualType _2
_1 |-->



typeDefns::
_1 = _2 |--><when> _2 functionType <action> _1 Function, _1`initValue _2`functInit
_1 = _2 |--><when> _2`isRecordType true <action> _1 Entity
_1 = _2 |--><when> _2`isSetType true <action> _1 Set
_1 = _2 |--><when> _2`isArrayType true <action> _1 Map, _1`initValue _2`typInit
_1 = _2 |--><when> _2`isFileType true <action> _1 File

_1 = _2 |--><when> _2`isScalarType true <action> _2`scalarLiterals with _1
_* |-->


functionType::
function : _1 |-->Function(OclAny,_1)
function _1 : _2 |-->_1`parsToFunctionDomain_2_1`parsFDomainsCloseBrackets

Function : _1 |-->Function(OclAny,_1)
Function _1 : _2 |-->_1`parsToFunctionDomain_2_1`parsFDomainsCloseBrackets


functInit::
function : _1 |-->lambda _x : OclAny in _1`typInit
function _1 : _2 |-->_1`functionInit _2`typInit

Function : _1 |-->lambda _x : OclAny in _1`typInit
Function _1 : _2 |-->_1`functionInit _2`typInit

_1 |-->_1`functInit<when> _1 functionType
_1 |-->null


procedureType::
procedure |-->Function(OclAny,OclAny)
procedure _1 |-->_1`parsToFunctionDomain OclAny_1`parsFDomainsCloseBrackets

Procedure |-->Function(OclAny,OclAny)
Procedure _1 |-->_1`parsToFunctionDomain OclAny_1`parsFDomainsCloseBrackets


isScalarType::
_1 |-->true<when> _1 scalarType
_1 |-->_1`isScalarType<when> _1 type_
_1 |-->_1`isScalarType<when> _1 simpleType
_1 |-->false


isSubrangeType::
_1 |-->true<when> _1 subrangeType
_1 |-->_1`isSubrangeType<when> _1 type_
_1 |-->_1`isSubrangeType<when> _1 simpleType
_1 |-->false


lowerBound::
( _1 ) |-->_1`first
_1 |-->_1`first<when> _1 subrangeType
_1 |-->_1`lowerBound<when> _1 type_
_1 |-->_1`lowerBound<when> _1 simpleType
_1 |-->_1`lowerBound<when> _1 subrangeType
_1 |-->0


isPointerType::
_1 |-->true<when> _1 pointerType
_1 |-->_1`isPointerType<when> _1 type_
_1 |-->_1`isPointerType<when> _1 simpleType
_1 |-->false


isSetType::
_1 |-->true<when> _1 setType
_1 |-->_1`isSetType<when> _1 type_
_1 |-->_1`isSetType<when> _1 structuredType
_1 |-->_1`isSetType<when> _1 unpackedStructuredType
packed _1 |-->_1`isSetType
_1 |-->false


isArrayType::
_1 |-->true<when> _1 arrayType
_1 |-->_1`isArrayType<when> _1 type_
_1 |-->_1`isArrayType<when> _1 structuredType
_1 |-->_1`isArrayType<when> _1 unpackedStructuredType
packed _1 |-->_1`isArrayType
_1 |-->false


isFileType::
_1 |-->true<when> _1 fileType
_1 |-->_1`isFileType<when> _1 type_
_1 |-->_1`isFileType<when> _1 structuredType
_1 |-->_1`isFileType<when> _1 unpackedStructuredType
packed _1 |-->_1`isFileType
_1 |-->false


isRecordType::
_1 |-->true<when> _1 recordType
_1 |-->_1`isRecordType<when> _1 type_
_1 |-->_1`isRecordType<when> _1 structuredType
_1 |-->_1`isRecordType<when> _1 unpackedStructuredType
packed _1 |-->_1`isRecordType
_1 |-->false


attributesFromFields::
record _1 end |-->_1
record end |-->
_1 |-->_1`attributesFromFields<when> _1 type_
_1 |-->_1`attributesFromFields<when> _1 structuredType
_1 |-->_1`attributesFromFields<when> _1 unpackedStructuredType
_1 |-->_1`attributesFromFields<when> _1 recordType
packed _1 |-->_1`attributesFromFields
_1 |-->


nestedClasses::
record _1 end |-->_1`innerClasses
record end |-->
_1 |-->_1`nestedClasses<when> _1 type_
_1 |-->_1`nestedClasses<when> _1 structuredType
_1 |-->_1`nestedClasses<when> _1 unpackedStructuredType
_1 |-->_1`nestedClasses<when> _1 recordType
packed _1 |-->_1`nestedClasses
_1 |-->


fieldList::
_1 ; _2 |-->_1_2
_1 |-->_1

fixedPart::
_1 ; _* |-->_1_*`recurse
_1 |-->_1


recordSection::
_1 : String |-->_1`allRecordFields<when> _1 multiple <action> _91 String
_1 : _2 |-->_1`allReferenceFields<when> _1 multiple, _2`isRecordType true <action> _92 _1`first
_1 : _2 |-->_1`allEntityFields<when> _1 multiple, _2 Entity <action> _93 _2
_1 : _2 |-->_1`allMapFields<when> _1 multiple, _2 Map <action> _94 _2
_1 : _2 |-->_1`allRecordFields<when> _1 multiple <action> _91 _2

_1 : String |-->\n  attribute _1 : String;<action> _1 String, _1`typName String

_1 : _2 |-->\n  reference _1 : _1_Class := _1_Class.new_1_Class();<when> _2`isRecordType true <action> _1 Entity, _1`typName _1_Class
_1 : _2 |-->\n  reference _1 : _2 := _2.new_2();<when> _2 Entity <action> _1 Entity, _1`typName _2

_1 : _2 |-->\n  attribute _1 : _2;


allRecordFields::
_* |-->_*`allFields


allFields::
, |-->
_1 |-->\n  attribute _1 : _91;


allReferenceFields::
_* |-->_*`allRefFields


allRefFields::
, |-->
_1 |-->\n  reference _1 : _92_Class := _92_Class.new_92_Class();<action> _1 Entity, _1`typName _92_Class


allEntityFields::
_* |-->_*`allEntFields


allEntFields::
, |-->
_1 |-->\n  reference _1 : _93 := _93.new_93();<action> _1 Entity, _1`typName _93


allMapFields::
_* |-->_*`allMpFields


allMpFields::
, |-->
_1 |-->\n  attribute _1 : _94 := Map{};<action> _1 Map, _1`typName _94


variantPart::
Case _1 Of _2 |-->_1_2
case _1 of _2 |-->_1_2
Case _1 Of _2 _* |-->_1_2_*
case _1 of _2 _* |-->_1_2_*

tag::
_1 : _2 |-->\n  attribute _1 : _2;
_1 |-->

variant::
_1 : ( _2 ) |-->_2


innerClasses::
_1 ; _2 |-->_1`innerClasses_2`innerClasses
_1 ; _* |-->_1`innerClasses_*`recurse
_1 : _2 |-->class _1`first_Class {\n_2`attributesFromFields\n\n  static operation new_1`first_Class() : _1`first_Class\n  pre: true\n  post: _1`first_Class->exists( _cc | result = _cc );\n\n}\n\n<when> _2`isRecordType true
_1 : _2 |-->
case _1 of _2 |-->_2`innerClasses
case _1 of _2 _* |-->2`innerClasses_*`innerClasses
_1 : ( _2 ) |-->_2`innerClasses
_1 |-->_1`innerClasses<when> _1 fixedPart
_1 |-->_1`innerClasses<when> _1 variantPart
_1 |-->


type_::
_1 |-->_1

pointedToType::
_1 |-->_1`pointedToType<when> _1 pointerType
^ _1 |-->_1


simpleType::
_1 |-->_1

scalarType::
( _1 ) |-->_1`scalarItems

scalarItems::
_1 |--> literal _1;
_1 , _* |--> literal _1; _*`recurse

scalarLiterals::
_1 |-->_1`scalarLiterals<when> _1 type_
_1 |-->_1`scalarLiterals<when> _1 simpleType
_1 |-->_1`scalarLiterals<when> _1 scalarType
( _1 ) |-->_1`scalarLiterals
_1 |-->_1<when> _1 identifier <action> _1`typName _$
_1 , _* |-->_*`recurse<when> _1 identifier <action> _1`typName _$


felemType::
_1 |-->_1`felemType<when> _1 type_
_1 |-->_1`felemType<when> _1 simpleType
_1 |-->_1`felemType<when> _1 scalarType
( _1 ) |-->_1`felemType
_1 |-->_1`typName<when> _1 identifier
_1 , _* |-->_1`typName<when> _1 identifier



subrangeType::
_1 .. _2 |-->int<when> _1`ocltype int
_1 .. _2 |-->String<when> _1`ocltype String
_1 .. _2 |-->_1`typName



structuredType::
PACKED _1 |-->_1
Packed _1 |-->_1
packed _1 |-->_1
_1 |-->_1


unpackedStructuredType::
_1 |-->_1


stringtype::
STRING [ _1 ] |-->String
String [ _1 ] |-->String
string [ _1 ] |-->String


indexType::
_1 |-->_1


componentType::
_1 |-->_1


setType::
SET OF _1 |-->Set(_1)
Set Of _1 |-->Set(_1)
set of _1 |-->Set(_1)


baseType::
_1 |-->_1


fileType::
File Of _1 |-->OclFile
file of _1 |-->OclFile
File |-->OclFile
file |-->OclFile


pointerType::
^ _1 |-->Ref(_1)


arrayType::
Array [ _1 ] Of _2 |-->_1`typesToMapDomains_2_1`closeBracketsMapDomains
array [ _1 ] of _2 |-->_1`typesToMapDomains_2_1`closeBracketsMapDomains


typeList::
_* |-->_*

typesToMapDomains::
_1 |-->Map(String,
_1 , _* |-->Map(String,_*`recurse

closeBracketsMapDomains::
_1 |-->)
_1 , _* |-->)_*`recurse

typesToMapInit::
_1 |-->_1`typRange->collect( _x | 
_1 , _* |-->_1`typRange->collect( _x | _*`recurse

closeBracketsMapInit::
_1 |-->)->unionAll()
_1 , _* |-->)->unionAll()_*`recurse

typeIdentifier::
CHAR |-->String
BOOLEAN |-->boolean
INTEGER |-->int
REAL |-->double
STRING |-->String
Char |-->String
String |-->String
Boolean |-->boolean
Integer |-->int
Real |-->double
ArbFloat |-->double

char |-->String
boolean |-->boolean
integer |-->int
real |-->double
string |-->String

shortInt |-->int
byte |-->int
smallInt |-->int
word |-->int
longInt |-->int
longint |-->int
longWord |-->int
int64 |-->long
qWord |-->long

_1 |-->_1


typRange::
_1 .. _2 |-->Integer.subrange(_1, _2)<when> _1`ocltype int
_1 .. _2 |-->Integer.subrange(_1->char2byte(), _2->char2byte())->collect(_x | _x->byte2char())<when> _1`ocltype String
_1 .. _2 |-->Integer.subrange(_1, _2)

( _1 ) |-->Integer.subrange(_1`first, _1`last)

_1 |-->Integer.subrange(0,255)->collect(_x | _x->byte2char())<when> _1 stringtype
_1 |-->_1`typRange<when> _1 simpleType
_1 |-->_1`typRange<when> _1 subrangeType
_1 |-->_1`typRange<when> _1 scalarType
_1 |-->_1`typRange<when> _1 indexType
_1 |-->_1




variableDeclarationPart::
Var _1 ; |-->_1\n
Var _* |-->_*`recurse
var _1 ; |-->_1\n
var _* |-->_*`recurse
_1 ; _* |-->_1_*`recurse
_1 ; |-->_1\n


localVariableDecs::
Var _1 ; |-->_1`localVarDeclaration\n
Var _* |-->_*`recurse
var _1 ; |-->_1`localVarDeclaration\n
var _* |-->_*`recurse
_1 ; _* |-->_1`localVarDeclaration_*`recurse
_1 ; |-->_1`localVarDeclaration\n


variableDeclaration::
_1 : _2 |-->_1`allMapVarDeclns<when> _1 multiple, _2 Map <action> _94 _2
_1 : _2 |-->_1`allMapVarDeclns<when> _1 multiple, _2`isArrayType true <action> _94 _2

_1 : _2 |-->_1`varDeclns<when> _1 multiple <action> _90 _2

_1 : String |-->\n  attribute _1 : String := "";<action> _1 String, _1`typName String
_1 : integer |-->\n  attribute _1 : int := 0;<action> _1 int, _1`typName int
_1 : real |-->\n  attribute _1 : double := 0.0;<action> _1 double, _1`typName double
_1 : boolean |-->\n  attribute _1 : boolean := false;<action> _1 boolean, _1`typName boolean

_1 : _2 |-->\n  attribute _1 : _2 := Set{};<when> _2`isSetType true <action> _1 Set, _1`typName _2
_1 : _2 |-->\n  attribute _1 : _2 := Set{};<when> _2 Set <action> _1 Set, _1`typName _2

_1 : _2 |-->\n  attribute _1 : _2 := _2`initValue;<when> _2 Map <action> _1 Map, _1`typName _2
_1 : _2 |-->\n  attribute _1 : _2 := _2`typInit;<when> _2`isArrayType true <action> _1 Map, _1`typName _2, _2`initValue _2`typInit

_1 : _2 |-->\n  attribute _1 : _2 := _2`functInit;<when> _2`isFunctionType true <action> _1 Function, _1`typName _2
_1 : _2 |-->\n  attribute _1 : _2 := _2`initValue;<when> _2 Function <action> _1 Function, _1`typName _2

_1 : _2 |-->\n  attribute _1 : _2;  attribute _1_buffer : String;<when> _2 File <action> _1 File, _1`typName _2
_1 : _2 |-->\n  attribute _1 : _2;\n  attribute _1_buffer : String;<when> _2`isFileType true <action> _1 File, _1`typName _2

_1 : _2 |-->\n  reference _1 : _2 := _2.new_2();<when> _2 Entity <action> _1 Entity, _1`typName _2

_1 : _2 |-->\n  attribute _1 : _2;<when> _2`isPointerType true, _2`pointedToType Entity <action> _1 Ref, _1`typName _2, _1`isObjectPointer true, _1`referredType _2`pointedToType

_1 : _2 |-->\n  attribute _1 : _2;<when> _2`isPointerType true <action> _1 Ref, _1`typName _2, _1`isObjectPointer false

_1 : _2 |-->\n  attribute _1 : _2;<action> _1 _2, _1`typName _2
_1 |-->


varDeclns::
_1 |-->_1`varDeclar
_* |-->_*`varDeclar

varDeclar::
, |-->
_1 |-->\n  attribute _1 : String := "";<when> _90 String <action> _1 String, _1`typName String
_1 |-->\n  attribute _1 : int := 0;<when> _90 int <action> _1 int, _1`typName int
_1 |-->\n  attribute _1 : double := 0.0;<when> _90 double <action> _1 double, _1`typName double
_1 |-->\n  attribute _1 : boolean := false;<when> _90 boolean <action> _1 boolean, _1`typName boolean

_1 |-->\n  reference _1 : _90 := _90.new_90();<when> _90 Entity <action> _1 Entity, _1`typName _90
_1 |-->\n  attribute _1 : _90 := Set{};<when> _90 Set <action> _1 Set, _1`typName _90
_1 |-->\n  attribute _1 : _90 := Map{};<when> _90 Map <action> _1 Map, _1`typName _90
_1 |-->\n  attribute _1 : _90;<when> _90 Function <action> _1 Function, _1`typName Function
_1 |-->\n  attribute _1 : _90;<action> _1 _90, _1`typName _90



allMapVarDeclns::
_1 |-->_1`mapVarDeclar
_* |-->_*`mapVarDeclar

mapVarDeclar::
, |-->
_1 |-->\n  attribute _1 : _94 := Map{};<action> _1 Map, _1`typName _94


typInit::
CHAR |-->""
Boolean |-->false
INTEGER |-->0
REAL |-->0.0
STRING |-->""
Char |-->""
Boolean |-->false
Integer |-->0
Real |-->0.0
String |-->""
char |-->""
boolean |-->false
integer |-->0
real |-->0.0
string |-->""

( _1 ) |-->_1`first
_1 .. _2 |-->_1

array [ _1 ] of _2 |-->_1`typesToMapInit Map{_x |-> _2`typInit}_1`closeBracketsMapInit

packed _1 |-->_1`typInit

_1 |-->_1`typInit<when> _1 _type
_1 |-->_1`typInit<when> _1 simpleType
_1 |-->_1`typInit<when> _1 structuredType
_1 |-->_1`typInit<when> _1 pointerType
_1 |-->_1`typInit<when> _1 scalarType
_1 |-->_1`typInit<when> _1 subrangeType
_1 |-->_1`typInit<when> _1 typeIdentifier
_1 |-->_1`typInit<when> _1 unpackedStructuredType
_1 |-->_1`typInit<when> _1 arrayType
_1 |-->_1`typInit<when> _1 pointerType
_1 |-->_1`typInit<when> _1 componentType

_1 |-->""<when> _1 stringType
_1 |-->null<when> _1 recordType
_1 |-->Set{}<when> _1 setType
_1 |-->null<when> _1 fileType

_1 |-->0



localVarDeclaration::
_1 : _2 |-->_1`localVarDeclns<when> _1 multiple <action> _90 _2

_1 : String |-->\n    var _1 : String := "";<action> _1 String, _1`typName String
_1 : integer |-->\n    var _1 : int := 0;<action> _1 int, _1`typName int
_1 : real |-->\n    var _1 : double := 0.0;<action> _1 double, _1`typName double
_1 : boolean |-->\n    var _1 : boolean := false;<action> _1 boolean, _1`typName boolean

_1 : _2 |-->\n    var _1 : _2 := Set{};<when> _2 Set <action> _1 Set, _1`typName _2

_1 : _2 |-->\n    var _1 : _2 := _2`initValue;<when> _2 Map <action> _1 Map, _1`typName _2
_1 : _2 |-->\n    var _1 : _2 := _2`typInit;<when> _2`isArrayType true <action> _1 Map, _1`typName _2, _2`initValue _2`typInit

_1 : _2 |-->\n    var _1 : _2;<when> _2 Function <action> _1 Function, _1`typName _2
_1 : _2 |-->\n    var _1 : _2 := _2.new_2();<when> _2 Entity <action> _1 Entity, _1`typName _2
_1 : _2 |-->\n    var _1 : _2;<when> _2`isPointerType true, _2`pointedToType Entity <action> _1 Ref, _1`typName _2, _1`isObjectPointer true, _1`referredType _2`pointedToType
_1 : _2 |-->\n    var _1 : _2;<when> _2`isPointerType true <action> _1 Ref, _1`typName _2, _1`isObjectPointer false
_1 : _2 |-->\n    var _1 : _2;<action> _1 _2, _1`typName _2
_1 |-->


localVarDeclns::
_* |-->_*`localVarDeclar

localVarDeclar::
, |-->
_1 |-->\n    var _1 : String := "";<when> _90 String <action> _1 String, _1`typName String
_1 |-->\n    var _1 : int := 0;<when> _90 int <action> _1 int, _1`typName int
_1 |-->\n    var _1 : double := 0.0;<when> _90 double <action> _1 double, _1`typName double
_1 |-->\n    var _1 : boolean := false;<when> _90 boolean <action> _1 boolean, _1`typName boolean

_1 |-->\n    var _1 : _90 := Set{};<when> _90 Set <action> _1 Set, _1`typName Set
_1 |-->\n    var _1 : _90 := Map{};<when> _90 Map <action> _1 Map, _1`typName Map
_1 |-->\n    var _1 : _90;<when> _90 Function <action> _1 Function, _1`typName Function
_1 |-->\n    var _1 : _90 := _90.new_90();<when> _90 Entity <action> _1 Entity, _1`typName _90
_1 |-->\n    var _1 : _90;<action> _1 _90, _1`typName _90





procedureAndFunctionDeclarationPart::
_1 ; |-->_1


procedureOrFunctionDeclaration::
_1 |-->_1


functionDeclaration::
function _1 : _2 ; _3 |-->\n  operation _1_operation() : _2\n  pre: true post: true\n  activity:  var _1 : _2;  _3`functionBlock;\n    return _1;\n\n  attribute _1 : Function(OclAny,_2) := lambda x : OclAny in (_1_operation());\n<action> _1`typName _2

function _1 _2 : _3 ; _4 |-->_4`nestedFunctions\n  operation _1_operation_2`parDecList : _3\n  pre: true post: true\n  activity: var _1 : _3;_2`copyValParameters  _4`functionBlock;\n    return _1;\n\n  attribute _1 : _2`parsToFunctionDomain_3_2`parsFDomainsCloseBrackets := _2`parsToLambdaDefinition (_1_operation(_2`parsToFunctionParlist));\n<action> _1`typName _3



procedureDeclaration::
procedure _1 _2 ; _3 |-->_3`nestedFunctions\n  operation _1_2`parDecList\n  pre: true post: true\n  activity: _2`copyValParameters  _3`functionBlock;\n

procedure _1 ; _2 |-->_2`nestedFunctions\n  operation _1()\n  pre: true post: true\n  activity: _2`functionBlock;\n



nestedFunctionDeclarations::
_1 |-->_1`nestedFunctionDeclarations<when> _1 procedureOrFunctionDeclaration
_1 ; |-->_1`nestedFunctionDeclarations<when> _1 procedureOrFunctionDeclaration

_1 |-->_1`nestedFunctionDeclarations<when> _1 functionDeclaration
_1 |-->_1`nestedFunctionDeclarations<when> _1 procedureDeclaration

function _1 _2 : _3 ; _4 |-->_4`nestedFunctions\n  operation _1_operation_2`parDecList : _3\n  pre: true post: true\n  activity: var _1 : _3;  _4`functionBlock;\n    return _1;\n

function _1 : _2 ; _3 |-->_3`nestedFunctions\n  operation _1_operation() : _2\n  pre: true post: true\n  activity:  var _1 : _2;  _3`functionBlock;\n    return _1;\n

procedure _1 _2 ; _3 |-->_3`nestedFunctions\n  operation _1_2`parDecList\n  pre: true post: true\n  activity: _3`functionBlock;\n

procedure _1 ; _2 |-->_2`nestedFunctions\n  operation _1()\n  pre: true post: true\n  activity: _2`functionBlock;\n



nestedFunctionVariables::
_1 |-->_1`nestedFunctionVariables<when> _1 procedureOrFunctionDeclaration
_1 ; |-->_1`nestedFunctionVariables<when> _1 procedureOrFunctionDeclaration

_1 |-->_1`nestedFunctionVariables<when> _1 functionDeclaration
_1 |--><when> _1 procedureDeclaration

function _1 _2 : _3 ; _4 |-->\n  var _1 : _2`parsToFunctionDomain_3_2`parsFDomainsCloseBrackets := _2`parsToLambdaDefinition (self._1_operation(_2`parsToFunctionParlist));\n

function _1 : _2 ; _3 |-->\n  var _1 : Function(OclAny,_2) := lambda x : OclAny in (self._1_operation());\n


rdFrame::
_1 ; _* |-->_1`rdFrame_*`recurse<when> _1 statement

_1 |-->_1`rdFrame<when> _1 statement
_1 |-->_1`rdFrame<when> _1 unlabelledStatement
_1 |--><when> _1 emptyStatement_
_1 |-->_1`rdFrame<when> _1 simpleStatement
_1 |-->_1`rdFrame<when> _1 assignmentStatement
_1 |-->_1`rdFrame<when> _1 compoundStatement
_1 |-->_1`rdFrame<when> _1 procedureStatement
_1 |-->_1`rdFrame<when> _1 structuredStatement 
_1 |-->_1`rdFrame<when> _1 conditionalStatement
_1 |-->_1`rdFrame<when> _1 repetetiveStatement
_1 |-->_1`rdFrame<when> _1 whileStatement
_1 |-->_1`rdFrame<when> _1 repeatStatement
_1 |-->_1`rdFrame<when> _1 forStatement
_1 |--><when> _1 gotoStatement
_1 |-->_1`rdFrame<when> _1 withStatement

_1 : _2 |-->_2`rdFrame
begin _1 end |-->_1`rdFrame
_1 := _2 |-->_2`readFrame
_1 ( _2 ) |-->


if _1 then _2 |-->_1`readFrame_2`rdFrame
if _1 then _2 else _3 |-->_1`readFrame_2`rdFrame_3`rdFrame

case _1 of _* else _2 end |-->_1`readFrame_*`rdCases_2`rdFrame
case _1 of _* end |-->_1`readFrame_*`rdCases

while _1 do _2  |-->_1`readFrame_2`rdFrame
repeat _1 until _2 |-->_1`rdFrame_2`readFrame

for _1 := _2 do _3 |-->_2`readFrame_3`rdFrame

with _1 to _2 |-->_2`rdFrame

_* |-->



rdCases::
_1 : _2 |-->_1`readFrame_2`rdFrame 
_1 |-->


statements::
_1 |-->_1
_* |-->_*


statement::
_1 |-->_1
_1 : _2 |-->_2

isLabelledStatement::
_1 |-->false
_1 : _2 |-->true

labelOfStatement::
_1 |-->
_1 : _2 |-->label__1



unlabelledStatement::
_1 |-->_1


simpleStatement::
emptyStatement_ |-->\n    skip
_1 |-->_1


assignmentStatement::
_1 := _2 |-->\n    _1 := _2->copy()<when> _2 Entity <action> _1 _2`ocltype
_1 := _2 |-->\n    _1 := _2->copy()<when> _2 Map <action> _1 _2`ocltype
_1 := _2 |-->\n    _1 := _2<action> _1 _2`ocltype


compoundStatement::
begin _1 end |-->\n    (_1  )


gotoFunctions::
begin _1 end |-->_1`gotoFunctions

_1 ; _* |-->\n    self._1`labelOfStatement();  return;\n\n  operation _1`labelOfStatement()\n  pre: true post: true\n  activity: _1 ; _*`recurse<when> _1`isLabelledStatement true
_1 ; _* |-->_1; _*`recurse

_1 |-->\n    self._1`labelOfStatement();  return;\n\n  operation _1`labelOfStatement()\n  pre: true post: true\n  activity: _1<when> _1`isLabelledStatement true
_1 |-->_1

; |-->skip


procedureStatement::
get ( _1 ) |-->\n    _1_buffer := _1.read()
put ( output ) |-->\n    output.print(output_buffer)
put ( _1 ) |-->\n    _1.write(_1_buffer)

writeln |-->\n    execute ""->display()
readln |-->\n    execute ""->display()

read ( _1 ) |-->_1`readStatement
readln ( _1 ) |-->_1`readlnStatement

write ( _1 ) |-->_1`writeStatement
writeln ( _1 ) |-->_1`writelnStatement
    
rewrite ( _1 ) |-->_1`rewriteStatement
reset ( _1 ) |-->_1`resetStatement

new ( _1 ) |-->\n    _1 := _1`typName{1}; !_1 := _1`referredType.new_1`referredType()<when> _1`isObjectPointer true
new ( _1 ) |-->\n    _1 := _1`typName{1}

dispose ( _1 ) |-->\n    execute (!_1)->isDeleted(); _1 := null<when> _1`isObjectPointer true
dispose ( _1 ) |-->\n    _1 := null

inc ( _1 ) |-->\n    _1`first := _1`first + _1`last<when> _1 multiple
dec ( _1 ) |-->\n    _1`first := _1`first - _1`last<when> _1 multiple

inc ( _1 ) |-->\n    _1 := _1 + 1
dec ( _1 ) |-->\n    _1 := _1 - 1

randomize |-->\n    var _random : OclRandom := OclRandom.newOclRandom()
randomize ( _1 ) |-->\n    var _random : OclRandom := OclRandom.newOclRandom_Seed(_1)


_1 ( _2 ) |-->\n    _1(_2)



readStatement::
_1 , _2 |-->\n    _2 := _1.readObject()->oclAsType(_2`typName)<when> _1`ocltype File, _2 Entity
_1 , _2 |-->\n    _2 := _1.read()<when> _1`ocltype File
_1 , _2 |-->\n    _1 := input.read();\n    _2 := input.read()
_1 |-->\n    _1 := input.read()


readlnStatement::
_1 , _2 |-->\n    _2 := _1.readLine()<when> _1`ocltype File
_1 , _2 |-->\n    _1 := input.readLine();\n    _2 := input.read()
_1 |-->\n    _1 := input.readLine()


writeStatement::
_1 |-->\n    output.print("" + _1`writeArguments)
_1 _* |-->\n    _1.write("" _*`writeArguments)<when> _1`ocltype File
_1 _* |-->\n    output.print("" + _1`writeArguments_*`writeArguments)



writelnStatement::
_1 |-->\n    execute ("" + _1`writeArguments)->display()

output _* |-->\n    execute ("" _*`writeArguments)->display()

_1 _* |-->\n    _1.writeln("" _*`writeArguments)<when> _1`ocltype File
_1 _* |-->\n    execute ("" + _1`writeArguments_*`writeArguments)->display()



writeArguments::
, |--> +

_1 _2 _3 |--> StringLib.format("%_2._3f", Sequence{_1})<when> _1`ocltype double
_1 _2 _3 |--> StringLib.format("%_2._3d", Sequence{_1})<when> _1`ocltype int
_1 _2 _3 |--> StringLib.format("%_2._3s", Sequence{"" + (_1)})

_1 _2 |--> StringLib.format("%_2f", Sequence{_1})<when> _1`ocltype double
_1 _2 |--> StringLib.format("%_2d", Sequence{_1})<when> _1`ocltype int
_1 _2 |--> StringLib.format("%_2s", Sequence{"" + (_1)})

_1 |--> _1


rewriteStatement::
_1 |-->\n    _1`first := OclFile.newOclFile_Write(_1`first)<when> _1 singleton
_1 |-->\n    _1`first := OclFile.newOclFile_Write(OclFile.newOclFile(_1`third))


resetStatement::
_1 |-->\n    _1`first := OclFile.newOclFile_Read(OclFile.newOclFile("_1`first"));\n    _1`first_buffer := _1`first.read()<when> _1 singleton
_1 |-->\n    _1`first := OclFile.newOclFile_Read(OclFile.newOclFile(_1`third))


actualParameter::
_1 |-->_1
_1 _* |-->_1



parameterwidth::
: _1 |-->_1
   

structuredStatement::
_1 |-->_1

conditionalStatement::
_1 |-->_1


ifStatement::
IF _1 THEN _2 |-->\n    if _1\n    then _2 else skip
IF _1 THEN _2 ELSE _3 |-->\n    if _1\n     then _2\n    else (_3)

If _1 Then _2 |-->\n    if _1\n    then _2 else skip
If _1 Then _2 Else _3 |-->\n    if _1\n    then _2\n    else (_3)

if _1 then _2 |-->\n    if _1\n    then _2 else skip
if _1 then _2 else _3 |-->\n    if _1\n     then _2\n    else (_3)


caseStatement::
CASE _1 OF _* ELSE _2 END |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase (_2)
CASE _1 OF _* END |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase skip

Case _1 Of _* Else _2 End |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase (_2)
Case _1 Of _* End |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase skip

case _1 of _* else _2 end |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase (_2)
case _1 of _* end |-->\n    var _case_var : _1`ocltype := _1;_*`caseCase skip


caseListElement::
_1 : _2 |-->

caseCase::
_1 : _2 |-->\n    if_1`caseTests\n    then _2\n    else 
_1 |-->


caseTests::
_* |-->_*`caseTestCase

caseTestCase::
, |--> or
_1 |--> _case_var = _1



repetetiveStatement::
_1 |-->_1


whileStatement::
WHILE _1 DO _2  |-->\n    while _1 do (_2)
While _1 Do _2  |-->\n    while _1 do (_2)
while _1 do _2  |-->\n    while _1 do (_2)


repeatStatement::
REPEAT _1 UNTIL _2 |-->\n    while true do (_1 ;\n      if _2 then break else skip)
Repeat _1 Until _2 |-->\n    while true do (_1 ;\n      if _2 then break else skip)
repeat _1 until _2 |-->\n    while true do (_1 ;\n      if _2 then break else skip)


forStatement::
FOR _1 := _2 DO _3 |-->\n    _1 := _2`startingValue;\n    while _1 _2`relOp _2`endingValue do\n    (_3;\n     _1 := _1_2`forAdvanceOperator)
For _1 := _2 Do _3 |-->\n    _1 := _2`startingValue;\n    while _1 _2`relOp _2`endingValue do\n    (_3;\n     _1 := _1_2`forAdvanceOperator)
for _1 := _2 do _3 |-->\n    _1 := _2`startingValue;\n    while _1 _2`relOp _2`endingValue do\n    (_3;\n     _1 := _1_2`forAdvanceOperator)


startingValue::
_1 TO _2 |-->_1
_1 To _2 |-->_1
_1 to _2 |-->_1

_1 DOWNTO _2 |-->_1
_1 DownTo _2 |-->_1
_1 Downto _2 |-->_1
_1 downto _2 |-->_1


endingValue::
_1 TO _2 |-->_2
_1 To _2 |-->_2
_1 to _2 |-->_2

_1 DOWNTO _2 |-->_2
_1 DownTo _2 |-->_2
_1 Downto _2 |-->_2
_1 downto _2 |-->_2


relOp::
_1 TO _2 |--><=
_1 To _2 |--><=
_1 to _2 |--><=

_1 DOWNTO _2 |-->>=
_1 DownTo _2 |-->>=
_1 Downto _2 |-->>=
_1 downto _2 |-->>=


forAdvanceOperator::
_1 TO _2 |--> + 1<when> _1`ocltype int
_1 To _2 |--> + 1<when> _1`ocltype int
_1 to _2 |--> + 1<when> _1`ocltype int

_1 TO _2 |-->->succ()
_1 To _2 |-->->succ()
_1 to _2 |-->->succ()

_1 DOWNTO _2 |--> - 1<when> _1`ocltype int
_1 DownTo _2 |--> - 1<when> _1`ocltype int
_1 Downto _2 |--> - 1<when> _1`ocltype int
_1 downto _2 |--> - 1<when> _1`ocltype int

_1 DOWNTO _2 |-->->pred()
_1 DownTo _2 |-->->pred()
_1 Downto _2 |-->->pred()
_1 downto _2 |-->->pred()


forList::
_1 TO _2 |-->Integer.subrange(_1,_2)<when> _1`ocltype int
_1 To _2 |-->Integer.subrange(_1,_2)<when> _1`ocltype int
_1 to _2 |-->Integer.subrange(_1,_2)<when> _1`ocltype int

_1 TO _2 |-->Integer.subrange(_1->char2byte(),_2->char2byte())->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 To _2 |-->Integer.subrange(_1->char2byte(),_2->char2byte())->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 to _2 |-->Integer.subrange(_1->char2byte(),_2->char2byte())->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 TO _2 |-->_1`typName.subrange(_1,_2)
_1 To _2 |-->_1`typName.subrange(_1,_2)
_1 to _2 |-->_1`typName.subrange(_1,_2)

_1 DOWNTO _2 |-->Integer.subrange(_2,_1)->reverse()<when> _1`ocltype int
_1 DownTo _2 |-->Integer.subrange(_2,_1)->reverse()<when> _1`ocltype int
_1 Downto _2 |-->Integer.subrange(_2,_1)->reverse()<when> _1`ocltype int
_1 downto _2 |-->Integer.subrange(_2,_1)->reverse()<when> _1`ocltype int
_1 DOWNTO _2 |-->Integer.subrange(_2->char2byte(),_1->char2byte())->reverse()->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 DownTo _2 |-->Integer.subrange(_2->char2byte(),_1->char2byte())->reverse()->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 Downto _2 |-->Integer.subrange(_2->char2byte(),_1->char2byte())->reverse()->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 downto _2 |-->Integer.subrange(_2->char2byte(),_1->char2byte())->reverse()->collect( _b | _b->byte2char() )<when> _1`ocltype String
_1 DOWNTO _2 |-->_1`typName.subrange(_2,_1)->reverse()
_1 DownTo _2 |-->_1`typName.subrange(_2,_1)->reverse()
_1 Downto _2 |-->_1`typName.subrange(_2,_1)->reverse()
_1 downto _2 |-->_1`typName.subrange(_2,_1)->reverse()


initialValue::
_1 |-->_1

finalValue::
_1 |-->_1


gotoStatement::
goto _1 |-->\n    self.label__1(); return


withStatement::
with _1 do _2 |-->\n    _1`first.with_op_2`hashCode(_2`rdFrame self)<action> _2`hashCode _2, _2`hashCode _1, _2`hashCode _2`rdFrame


recordVariableList::
_1 |-->_1
_* |-->_*



variable::
input ^ |-->input_buffer
output ^ |-->output_buffer
_1 ^ |-->_1_buffer<when> _1`ocltype File

@ _1 |-->?_1
@ _* |-->(?(_*`recurse))
_* ^ |-->(!(_*`recurse))
_* ^ _+ |-->(!(_*`recurse))_+`recurse
_1 [ _2 ] |-->_1["" + _2]
_1 [ _2 ] _* |-->_1["" + _2]_*`recurse
_1 [ _2 , _* |-->_1["" + _2][_*`recurse
_1 ] |-->"" + _1]
_1 ] _* |-->"" + _1]_*`recurse
_1 . _2 |-->_1._2
_1 . _* |-->_1._*`recurse
. _1 |-->._1
. _* |-->._*`recurse
_1 |-->_1<when> _1 identifier


readFrame::
input ^ |-->input_buffer,
output ^ |-->output_buffer,
_1 ^ |-->_1_buffer,<when> _1`ocltype File

@ _1 |-->_1`readFrame
@ _* |-->_*`readFrame
_* ^ |-->_*`readFrame
_* ^ _+ |-->_*`readFrame_+`readFrame
_1 [ _2 ] |-->_1`readFrame_2`readFrame
_1 [ _2 ] _* |-->_1`readFrame_2`readFrame_*`readFrame
_1 [ _2 , _* |-->_1`readFrame_2`readFrame_*`readFrame
_1 ] |-->_1`readFrame
_1 ] _* |-->_1`readFrame_*`readFrame
_1 . _2 |-->_1`readFrame
_1 . _* |-->_1`readFrame
. _1 |-->
. _* |-->

_1 to _2 |-->_1`readFrame_2`readFrame
_1 downto _2  |-->_1`readFrame_2`readFrame

_1 |-->_1,<when> _1 identifier
_1 |--><when>_1 unsignedNumber
_1 |--><when> _1 unsignedInteger
_1 |--><when> _1 unsignedConstant
_1 |--><when> _1 unsignedReal
_1 |--><when> _1 string
_1 |-->_1`readFrame<when> _1 finalValue
_1 |-->_1`readFrame<when> _1 initialValue
_1 |-->_1`readFrame<when> _1 constant
_1 |-->_1`readFrame<when> _1 unsignedConstant
_1 |-->_1`readFrame<when> _1 factor
_1 |-->_1`readFrame<when> _1 term
_1 |-->_1`readFrame<when> _1 signedFactor
_1 |-->_1`readFrame<when> _1 parameterList
_1 |-->_1`readFrame<when> _1 actualParameter
_1 |-->_1`readFrame<when> _1 expression
_1 |-->_1`readFrame<when> _1 simpleExpression
_1 |-->_1`readFrame<when> _1 functionDesignator
_1 |-->_1`readFrame<when> _1 variable

_1 = _2 |-->_1`readFrame_2`readFrame
_1 <> _2 |-->_1`readFrame_2`readFrame
_1 < _2 |-->_1`readFrame_2`readFrame
_1 <= _2 |-->_1`readFrame_2`readFrame
_1 > _2 |-->_1`readFrame_2`readFrame
_1 >= _2 |-->_1`readFrame_2`readFrame
_1 in _2 |-->_1`readFrame_2`readFrame
_1 + _2 |-->_1`readFrame_2`readFrame
_1 - _2 |-->_1`readFrame_2`readFrame
_1 or _2 |-->_1`readFrame_2`readFrame
_1 * _2 |-->_1`readFrame_2`readFrame
_1 div _2 |-->_1`readFrame_2`readFrame
_1 mod _2 |-->_1`readFrame_2`readFrame
_1 and _2 |-->_1`readFrame_2`readFrame

+ _1 |-->_1`readFrame
- _1 |-->_1`readFrame
( _1 ) |-->_1`readFrame
not _1 |-->_1`readFrame

nil |-->

_1 ( _2 ) |-->_2`readFrame



expression::
_1 |-->_1
_1 = _2 |-->_1 = _2
_1 <> _2 |-->_1 /= _2
_1 < _2 |-->_1 < _2
_1 <= _2 |-->_2->includesAll(_1)<when> _1 Set
_1 <= _2 |-->_1 <= _2
_1 > _2 |-->_1 > _2
_1 >= _2 |-->_1->includesAll(_2)<when> _1 Set
_1 >= _2 |-->_1 >= _2
_1 in _2 |-->_2->includes(_1)


simpleExpression::
_1 |-->_1
_1 + _2 |-->_1->union(_2)<when> _1 Set
_1 + _2 |-->(_1 + _2)
_1 - _2 |-->(_1 - _2)
_1 or _2 |-->(_1 or _2)
_1 _2 _3 |-->_1 _2 _3


term::
_1 |-->_1
_1 * _2 |-->_1->intersection(_2)<when> _1 Set
_1 * _2 |-->(_1*_2)

_1 div _2 |-->(_1 div _2)
_1 mod _2 |-->(_1 mod _2)
_1 and _2 |-->(_1 & _2)

_1 _2 _3 |-->_1 _2 _3


signedFactor::
+ _1 |-->_1
- _1 |-->-(_1)
_1 |-->_1


factor::
_1 |-->_1
( _1 ) |-->(_1)
not _1 |-->not(_1)


unsignedConstant::
nil |-->null
_1 |-->_1


functionDesignator::
sin ( _1 ) |-->(_1)->sin()
cos ( _1 ) |-->(_1)->cos()
tan ( _1 ) |-->(_1)->tan()

odd ( _1 ) |-->((_1 mod 2) = 1)

arctan ( _1 ) |-->(_1)->atan()

abs ( _1 ) |-->(_1)->abs()
exp ( _1 ) |-->(_1)->exp()
ln ( _1 ) |-->(_1)->log()
round ( _1 ) |-->(_1)->round()
trunc ( _1 ) |-->(_1)->oclAsType(int)

sqr ( _1 ) |-->(_1)->sqr()
sqrt ( _1 ) |-->(_1)->sqrt()

chr ( _1 ) |-->(_1)->byte2char()

ord ( true ) |-->1
ord ( false ) |-->0

ord ( _1 ) |-->(_1)->char2byte()<when> _1`ocltype String
ord ( _1 ) |-->_1<when> _1`ocltype int
ord ( _1 ) |-->_1->ord()


succ ( _1 ) |-->((_1)->char2byte() + 1)->byte2char()<when> _1`ocltype String
succ ( _1 ) |-->_1->succ()

pred ( _1 ) |-->((_1)->char2byte() - 1)->byte2char()<when> _1`ocltype String
pred ( _1 ) |-->_1->pred()

eof ( _1 ) |-->_1.getEof()
eoln ( _1 ) |-->(_1_buffer->char2byte() = 10)

random ( _1 ) |-->_random.nextInt(_1)

_1 ( _2 ) |-->_1_2`cascadedApply<when> _1 Function
_1 ( _2 ) |-->_1_operation(_2)


parameterList::
_1 |-->_1
_* |-->_*


cascadedApply::
_1 |-->->apply(_1)
_1 , _* |-->->apply(_1)_*`recurse


set_::
[ ] |-->Set{}
[ _1 ] |-->Set{}_1


elementList::
_1 |-->_1
_1 , _* |-->_1_*`recurse


element::
_1 |-->->union(Set{_1})
_1 .. _2 |-->->union(Integer.subrange(_1,_2))<when> _1`ocltype int
_1 .. _2 |-->->union(Integer.subrange(_1->char2byte(),_2->char2byte())->collect(_x | _x->byte2char()))<when> _1`ocltype String
_1 .. _2 |-->->union(Integer.subrange(_1,_2))




identifierList::
_1 |-->_1
_* |-->_*


constList::
_1 |-->_1
_* |-->_*


relationaloperator::
<> |-->/=
IN |-->:
In |-->:
in |-->:
_1 |-->_1


multiplicativeoperator::
DIV |-->div
Div |-->div
MOD |-->mod
Mod |-->mod
AND |-->&
And |-->&
and |-->&
_1 |-->_1


additiveoperator::
OR |-->or
Or |-->or
_1 |-->_1


numberOfArguments::
_1 , _2 , _3 , _4 |-->4
_1 , _2 , _3 |-->3
_1 , _2 |-->2
_1 |-->1




formalParameterList::
( _1 ) |-->(_1)
( _* ) |-->( _* )


formalParameterSection::
; |-->,
var _1 |-->_1
function _1 |-->_1
procedure _1 |-->_1
_1 |-->_1`valueParameterGroup


parameterGroup::
_1 : _2 |-->_1`varParsList<when> _1 multiple <action> _95 _2

_1 : _2 |-->_1 : _2<when> _2 Function <action> _1 Function, _1`typName _2
_1 : _2 |-->_1 : _2<action> _1 _2, _1`typName _2
_1 |-->_1


valueParameterGroup::
_1 : _2 |-->_1`valueParsList<when> _1 multiple <action> _95 _2

_1 : _2 |-->_1 : _2<when> _2 Function <action> _1 Function, _1`typName _2
_1 : _2 |-->_1_copy : _2<when> _2 Map <action> _1 Map, _1`typName _2
_1 : _2 |-->_1_copy : _2<when> _2 Entity <action> _1 Entity, _1`typName _2

_1 : _2 |-->_1 : _2<action> _1 _2, _1`typName _2
_1 |-->_1


valueParsList::
_* |-->_*`valueParsPar

valueParsPar::
, |-->,
_1 |-->_1 : _95<when> _95 Set <action> _1 Set, _1`typName Set
_1 |-->_1_copy : _95<when> _95 Map <action> _1 Map, _1`typName Map
_1 |-->_1 : _95<when> _95 Function <action> _1 Function, _1`typName Function
_1 |-->_1_copy : _95<when> _95 Entity <action> _1 Entity, _1`typName _95

_1 |-->_1 : _95<action> _1 _95, _1`typName _95


varParsList::
_* |-->_*`varParsPar

varParsPar::
, |-->,
_1 |-->_1 : _95<when> _95 Set <action> _1 Set, _1`typName Set
_1 |-->_1 : _95<when> _95 Map <action> _1 Map, _1`typName Map
_1 |-->_1 : _95<when> _95 Function <action> _1 Function, _1`typName Function
_1 |-->_1 : _95<when> _95 Entity <action> _1 Entity, _1`typName _95

_1 |-->_1 : _95<action> _1 _95, _1`typName _95


parsToFunctionDomain::
( _1 ) |-->_1`parsToFunctionDomain
( _* ) |-->_*`parsToFunctionDomain
var _1 |-->_1`parFunctionDomains
function _1 |-->_1`parFunctionDomains
procedure _1 |-->_1`parFunctionDomains
; |-->
_1 |-->_1`parFunctionDomains


parFunctionDomains::
; |-->
_1 : _2 |-->Function(_2,

parsFDomainsCloseBrackets::
( _1 ) |-->_1`parsFDomainsCloseBrackets
( _* ) |-->_*`parsFDomainsCloseBrackets
var _1 |-->_1`parsFDomainCloseBrackets
function _1 |-->_1`parsFDomainCloseBrackets
procedure _1 |-->_1`parsFDomainCloseBrackets
; |-->
_1 |-->_1`parsFDomainCloseBrackets

parsFDomainCloseBrackets::
; |-->
_1 : _2 |-->)


functionInit::
( _1 ) |-->_1`functionInit
( _* ) |-->_*`functionInit
var _1 |-->_1`functionParInit
function _1 |-->_1`functionParInit
procedure _1 |-->_1`functionParInit
; |-->
_1 |-->_1`functionParInit

functionParInit::
; |-->
_1 : _2 |--> lambda _1 : _2 in 


parsToFunctionParlist::
( _1 ) |-->_1`parsToFunctionParlist
( _* ) |-->_*`parsToFunctionParlist
var _1 |-->_1`parFunctionPars
function _1 |-->Function
procedure _1 |-->Function
; |-->,
_1 |-->_1`parFunctionPars

parFunctionPars::
; |-->,
_1 : _2 |-->_1
_1 |-->_1


parDecList::
( _1 ) |-->(_1`parDecList)
( _* ) |-->(_*`parDecList)
var _1 |-->_1`parsDecs
function _1 |-->_1`parsDecs
procedure _1 |-->_1`parsDecs
; |-->,
_1 |-->_1`valParsDecs

parsDecs::
; |-->,

_1 : _2 |-->_1`varParsList<when> _1 multiple <action> _95 _2

_1 : _2 |-->_1 : _2
_1 |-->_1


valParsDecs::
; |-->,

_1 : _2 |-->_1`valueParsList<when> _1 multiple <action> _95 _2

_1 : _2 |-->_1_copy : _2<when> _2 Map
_1 : _2 |-->_1_copy : _2<when> _2 Entity
_1 : _2 |-->_1 : _2
_1 |-->_1


copyValParameters::
_1 : _2 |-->\n    var _1 : _2 := _1_copy->copy();<when> _2 Map
_1 : _2 |-->\n    var _1 : _2 := _1_copy->copy();<when> _2 Entity
_1 : _2 |-->

( _1 ) |-->_1`copyValParameters
( _* ) |-->_*`copyValParameters
var _1 |-->
function _1 |-->
procedure _1 |-->
; |-->
_1 |-->_1`copyValParameters<when> _1 parameterGroup
_1 |-->


parsToLambdaDefinition::
( _1 ) |-->_1`parsToLambdaDefinition
( _* ) |-->_*`parsToLambdaDefinition
var _1 |-->_1`parLambdaDefinition
function _1 |-->_1`parLambdaDefinition
procedure _1 |-->_1`parLambdaDefinition
; |-->
_1 |-->_1`parLambdaDefinition

parLambdaDefinition::
; |-->
_1 : _2 |--> lambda _1 : _2 in


resultType::
_1 |-->_1



